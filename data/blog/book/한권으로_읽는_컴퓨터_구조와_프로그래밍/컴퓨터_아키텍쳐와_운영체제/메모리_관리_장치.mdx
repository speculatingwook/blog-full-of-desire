---
title: '메모리 관리 장치(MMU, memory management unit)'
date: '2023-05-23'
tags: ['COMPUTER_SCIENCE', 'ARCHITECTURE', '한권으로_읽는_컴퓨터_구조와_프로그래밍']
draft: false
summary: '전공공부하면서 같이 공부하는 운영체제'
---

## MMU(memory managing unit)

멀티태스킹은 사치품에서 필수품으로 변해 왔다. 이제는 모든 것이 인터넷에 연결되어 있고, 통신 작업은 계속해서 백그라운드(background)에서 실행(즉 사용자가 실행 중인 프로그램과 더불어 실행 된다는 뜻이다)돼야 하기 때문에 멀티태스킹이 필수다. 인덱스 레지스터와 상대 주소 지정이 멀티태스킹에 도움이 될 수 있지만, 이들만으로 충분하지는 않다. 프로그램에 버그가 있으면 어떤 일이 벌어질까?

<p align="center">
  <img
    width="273"
    alt="image"
    src="https://user-images.githubusercontent.com/105579811/232542443-9eec5402-62dc-417c-b8b7-9b649293c324.png"
  />
</p>

예를 들어 사용자 프로그램2에 버그가 있어서 사용자 프로그램 1이 차지한 메모리를 덮어쓰거나, 심지어 OS의 메모리를 덮어쓴다면 어떤 일이 벌어질까? 누군가 의도적으로 시스템에 실행 중인 다른 사람의 프로그램을 들여다보거나 변경하는 프로그램을 작성한다면? 각 프로그램을 분리해서 이런 시나리오가 아예 불가능하게 할 수 있으면 정말 좋다. 이를 위해 오늘날 대부분의 마이크로프로세서에는 **메모리 관리 장치(MMU, memory management unit)** 가 들어 있다. MMU는 아주 복잡한 하드웨어다.

## MMU의 구조

<p align="center">
  <img
    width="708"
    alt="image"
    src="https://user-images.githubusercontent.com/105579811/232543341-af0254ae-6de0-4df3-a3c4-e4f60888451e.png"
  />
</p>

MMU가 들어 있는 시스템은 **가상 주소(virtual address)** 와 **물리 주소(physical address)** 를 구분한다. 그럼 위 그림처럼 프로그램은 가상 주소를 사용해 작성되고, MMU는 가상 주소를 물리 주소로 변환해준다.

<p align="center">
  <img
    width="896"
    alt="image"
    src="https://user-images.githubusercontent.com/105579811/232544134-aa033dba-60b0-4f5e-a3d7-aeadbdf9d0c8.png"
  />
</p>

MMU와 인덱스 레지스터는 어떤 차이가 있을까? 음, 차이가 여러 가지 있다. 그리고 MMU의 가상 주소 범위는 물리적 메모리 주소보다 큰 경우가 많다. 어떻게 그런 일이 가능할까? MMU는 가상 메모리 주소를 두 부분으로 나눈다. 주소의 하위(LSB 쪽) 부분은 물리적 주소 범위와 같다.상위(MSB 쪽) 부분은 페이지 테이블(Page table)이라는 RAM 영역을 통해 주소를 변환(translation)한다.
한다. 이 과정이 위에 나타나 있다.

이 예제에서 메모리는 256바이트 크기의 페이지(Page)로 분할된다. 페이지 테이블에는 각 페이지 가 물리 메모리상에서 차지하는 실제 위치 정보가 들어 있다. 이를 통해 1000번지(가상 메모리) 에서 시작하는 프로그램을 2000번지(물리 메모리)나 다른 곳에 넣을 수 있다. 물론 모든 내용이 페이지 경계(Page boundary) 안에 들어 있어야 한다. 그리고 프로그램 입장에서는 가상 메모리가 연속적인 것처럼 보이지만, 실제 물리 메모리상의 위치는 굳이 연속적일 필요가 없다. 심지어 프로그램이 실행되는 도중에 프로그램이 위치한 물리적 메모리 주소가 바뀔 수도 있다. 그리고 프로그램들이 서로 협력하는 경우에는 여러 프로그램의 가상 메모리 중 일부가 같은 물리 메모리를 함께 사용하는 공유 메모리(shared memory) 기능을 제공할 수도 있다. 이제 페이지 테이블의 내용 이 프로그램 문맥의 일부분이 된다는 사실에 유의하라.

현대적 프로세서의 MMU는 페이지 테이블 크기가 정해져있다.전체 페이지 테이블항목(pagetable entry)은 주 메모리에 저장되거나 주 메모리가 부족한 경우 디스크에 저장된다. MMU는 페이지 테이블 항목 중 일부를 필요할 때만 자신의 페이지 테이블로 읽어 들인다.

일부 MMU 설계는 페이지 테이블에 제어 비트를 추가 제공한다. 이런 제어 비트의 예로 실행 불가 비트(no execute bit)를 들 수 있다. 어떤 페이지에 대해 실행 불가 비트가 설정되어 있으면 CPU가 이 페이지에 있는 명령어를 실행할 수 없다. 따라서 프로그램이 실수로 자기 데이터를 실행하는 경우를 방지할 수 있다. 데이터 부분을 실행할 수 있으면(프로그램을 실행 시점에 마음대로 바꿔 쓸 수 있기 때문에) 보안 문제가 생길 수도 있다. 또 다른 일반적인 제어 비트로는 페이지를 읽기 전용(read only)으로 만드는 비트가 있다.

프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 페이지 폴트(page fault) 예외가 발생한다. 이런 동작은 스택 오버플로 등이 일어날 때 유용하게 쓰일 수 있다. 스택 오버플로가 발생하면 스택 범위를 벗어나는 주소에 접근하므로 페이지 폴트가 발생하고, 이 예외가 발생하면 OS는 실행 중인 프로그램을 중단시키는 대신 MMU가 추가 메모리를 할당하게 해서 스택 공간을 늘리고 사용자 프로그램 실행을 계속할 수 있다.

MMU로 인해 폰 노이만 구조와 하버드 구조의 구분이 의미 없어졌다. 단일 메모리 버스만 사용 하는 폰 노이만 구조의 시스템도 명령어 메모리와 데이터 메모리를 분리해 제공할 수 있다.

## 페이지 폴트

페이지 폴트(Page Fault)는 가상 메모리 시스템에서 발생하는 상황으로, 프로세스가 요청한 페이지가 현재 물리 메모리에 없는 경우를 의미합니다. 페이지 폴트 메커니즘은 이러한 페이지 폴트 상황을 처리하는 방법을 말합니다.

페이지 폴트 메커니즘은 다음과 같은 일반적인 절차로 진행됩니다:

1. 페이지 폴트 발생: 프로세스가 가상 주소를 통해 페이지에 접근할 때, MMU가 해당 페이지의 프레임(Frame)이 물리 메모리에 없음을 감지하고 페이지 폴트를 발생시킵니다.

2. 페이지 폴트 핸들링: 페이지 폴트를 처리하기 위해 운영체제에게 제어가 넘어갑니다. 운영체제는 다음과 같은 작업을 수행합니다:

   - 페이지 폴트 원인 분석: 물리 메모리에 없는 페이지의 경우, 해당 페이지를 디스크에서 가져와야 하는데, 이를 위해 해당 페이지가 어떤 위치에 저장되어 있는지 확인합니다.
   - 페이지 스왑(Swapping) 또는 페이지 부재(Page Fault) 처리: 페이지 폴트 원인을 해결하기 위해 디스크에서 해당 페이지를 가져옵니다. 이를 위해 페이지 교체 알고리즘을 사용하여 물리 메모리에서 페이지를 제거하고 디스크로 스왑하거나, 새로운 빈 프레임에 페이지를 로드합니다.
   - 페이지 테이블 갱신: 페이지 폴트로 인해 페이지 테이블의 엔트리를 갱신하여 가상 주소와 물리 주소의 매핑을 변경합니다.
   - 재시작: 페이지 폴트를 처리한 후, 해당 프로세스를 재개하고 중단된 명령을 다시 실행합니다.

3. 접근 재시도: 페이지 폴트 처리 이후, 프로세스는 요청한 페이지에 다시 접근하여 해당 데이터를 읽거나 쓸 수 있습니다.

페이지 폴트 메커니즘은 가상 메모리 시스템의 핵심적인 부분으로, 효율적인 페이지 교체 알고리즘과 페이지 부재 처리 기법을 사용하여 시스템 성능을 향상시킵니다. 페이지 폴트는 자주 발생할 수 있으므로, 페이지 폴트 처리의 효율성은 시스템의 성능에 큰 영향을 미칩니다.
