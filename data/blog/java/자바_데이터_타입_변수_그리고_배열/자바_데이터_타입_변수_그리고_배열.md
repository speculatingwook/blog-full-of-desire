---
title: '자바 데이터 타입, 변수 그리고 배열'
date: '2023-04-30'
tags: ['JAVA']
draft: false
summary: '자바라는 언어를 이해해보자!'
---

## 자바의 프리미티브 타입 종류와 범위 그리고 기본값

자바의 프리미티브 타입 종류와 값의 범위, 그리고 기본 값은 다음과 같다.

| 데이터 타입 | 데이터  | 메모리 크기 | 값의 범위                                              | 기본 값  |
| ----------- | ------- | ----------- | ------------------------------------------------------ | -------- |
| boolean     | 참/거짓 | 1byte       | true 또는 false                                        | false    |
| byte        | 정수    | 1byte       | -128 ~ 127                                             | 0        |
| short       | 정수    | 2byte       | -32,768 ~ 32,767                                       | 0        |
| int         | 정수    | 4byte       | -2,147,483,648 ~ 2,147,483,647                         | 0        |
| long        | 정수    | 8byte       | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 0L       |
| float       | 실수    | 4byte       | 1.4E-45 ~ 3.4028235E38                                 | 0.0f     |
| double      | 실수    | 8byte       | 4.9E-324 ~ 1.7976931348623157E308                      | 0.0d     |
| char        | 문자    | 2byte       | '\u0000' ~ '\uffff' (0 ~ 65,535) - 모든 유니코드 문자  | '\u0000' |

```java
boolean bool = true;
byte b = 10;
short s = 200;
int i = 10000;
long l = 1000000000L;
float f = 3.14f;
double d = 3.141592;
char c = 'A';

System.out.println(bool); // true
System.out.println(b); // 10
System.out.println(s); // 200
System.out.println(i); // 10000
System.out.println(l); // 1000000000
System.out.println(f); // 3.14
System.out.println(d); // 3.141592
System.out.println(c); // A
```

기본 값으로 초기화하지 않은 변수를 사용하면 컴파일 오류가 발생할 수 있으므로 주의해야 한다.

## 프리미티브 타입과 레퍼런스 타입

자바에서는 데이터 타입을 프리미티브 타입과 레퍼런스 타입 두 가지로 분류한다.

프리미티브 타입은 boolean, byte, short, int, long, float, double, char 총 8가지가 있다. 이들은 자바에서 기본적으로 제공되는 타입으로, 값 자체가 메모리에 저장된다. 프리미티브 타입의 변수를 선언할 때, 해당 타입의 값을 직접 저장할 수 있다.

레퍼런스 타입은 객체를 가리키는 참조값(주소값)을 저장하는 타입이다. 이들은 프로그래머가 직접 만든 클래스, 인터페이스, 배열 등이 포함된다. 레퍼런스 타입은 변수가 참조하는 객체의 주소를 저장하며, 객체의 멤버 변수나 메서드 등을 사용할 수 있다. 레퍼런스 타입의 변수를 선언할 때, 해당 타입의 객체를 생성하여 할당하거나, null로 초기화할 수 있다.

래퍼런스 타입의 데이터 크기는 가변적이고, 동적이기 때문에 동적으로 관리되는 Heap 메모리 영역에 주소값을 저장한다.

또한, 래퍼런스 타입은 빈 객체를 의미하는 Null값을 가지며, 호출이 완료된 후 더 이상 참조하는 값이 없다면 Java가 판단해 Garbage Collection을 진행한다.

프리미티브 타입과 래퍼런스 타입의 가장 큰 차이점은 호출 방식이다.

<p align="center">
    <img width="345" alt="image" src="https://user-images.githubusercontent.com/105579811/235335653-bb8d49ec-42f8-431d-b5e1-258d7b21155a.png"/>
</p>

프리미티브 타입의 경우 값에 의한 호출(Call By Value)로 변수를 호출하므로 메모리에서 변수의 값을 복사해서 사용하기 때문에 변수의 값을 바꾸더라도 메모리에 있는 값이 바뀌지 않는다.

하지만, 래퍼런스 타입의 경우 참조에 의한 호출(Call By Reference)로 호출한다.

여기서 참조에 의한 호출(Call By Reference)란 호출되는 변수의 메모리 주소를 복사해서 사용하는 것이다. 따라서, 참조에 의한 호출로 가져온 변수의 값을 바꾼다면 메모리 주소를 참조하여 사용했기 때문에 값이 바뀐다.

```java
// 프리미티브 타입 사용 예시
int number = 10; // int 타입의 변수 number를 선언하고 10을 저장
boolean flag = true; // boolean 타입의 변수 flag를 선언하고 true를 저장

// 레퍼런스 타입 사용 예시
String str = "Hello, world!"; // String 클래스의 인스턴스를 생성하여 str 변수에 할당
Object obj = new Object(); // Object 클래스의 인스턴스를 생성하여 obj 변수에 할당
int[] arr = new int[5]; // int 배열을 생성하여 arr 변수에 할당

```

## 리터럴

자바에서 리터럴(literal)은 소스 코드에서 직접 입력된 값을 의미합니다. 즉, 리터럴은 변수에 할당되는 고정 값이며, 변수를 초기화하는 데 사용된다.

자바에서는 다양한 타입의 리터럴을 지원한다.

예를 들어,
정수 리터럴: 10, 0b1010 (2진수), 012 (8진수), 0xA (16진수)
실수 리터럴: 3.14, 2.0F (float 타입), 1.5D (double 타입)
문자 리터럴: 'A', '\n' (개행), '\u0041' (유니코드)
문자열 리터럴: "Hello, world!", "Java"
논리 리터럴: true, false

```java
// 정수 리터럴
byte b = 10;           // byte 타입에 대한 정수 리터럴
short s = 100;
int i = 1000;
long l = 10000000000L; // long 타입에 대한 정수 리터럴 (L 접미사를 사용하여 지정)

// 실수 리터럴
float f = 1.23f;     // float 타입에 대한 실수 리터럴 (f 접미사를 사용하여 지정)
double d = 3.141592; // double 타입에 대한 실수 리터럴

// 문자 리터럴
char c = 'A';       // char 타입에 대한 문자 리터럴
char c1 = '\u1001'  // 문자 리터럴(유니코드)

// 문자열 리터럴
String str = "Hello, World!"; // String 타입에 대한 문자열 리터럴

// 논리 리터럴
boolean b1 = true; // boolean 타입에 대한 논리 리터럴
boolean b2 = false;
```

리터럴은 자료형을 갖고 있으며, 리터럴의 값이 자료형의 범위를 벗어나는 경우 컴파일 에러가 발생한다. 예를 들어, byte 타입의 범위는 -128부터 127까지인데, 200이라는 값을 할당하면 컴파일 에러가 발생한다.

리터럴은 상수(constant)와 혼동되지만, 상수는 리터럴로만 이루어진 표현식을 의미한다. 상수는 final 예약어를 사용하여 정의할 수 있다.

## 변수 선언 및 초기화 하는 방법

```java
class SubMain {
    private int sub;
}

class Main {
    public static void main(String[] args) {
        int a = 10;           //기본 타입 10 초기화
        int b;                //초기화 x
        int c, d;              //여러개 변수 선언(초기화 x)
        int e = 10, f = 5;    //여러개 변수 선언(초기화 o)
        Sub sub = new Sub();  //레퍼런스 타입 선언
    }
}
```

## 변수의 스코프와 라이프타임

변수의 스코프(scope)는 해당 변수가 유효한 범위를 의미하며, 라이프타임(lifetime)은 변수가 존재하는 시간을 의미한다. 자바에서 변수는 스코프에 따라 지역 변수(local variable)와 전역 변수(global variable)로 나눌 수 있으며, 라이프타임에 따라 지역 변수는 메서드 실행 시 생성되어 메서드 종료 후 소멸되고, 전역 변수는 프로그램 시작 시 생성되어 프로그램 종료 시 소멸된다.

예를 들어, 다음은 변수의 스코프와 라이프타임을 설명하는 간단한 자바 코드이다.

```java
public class ScopeAndLifetime {

    // 전역 변수
    static int globalVariable = 10;

    public static void main(String[] args) {
        // 지역 변수
        int localVariable = 20;

        System.out.println("globalVariable: " + globalVariable);
        System.out.println("localVariable: " + localVariable);

        if (globalVariable > localVariable) {
            // 지역 변수
            int innerVariable = 30;
            System.out.println("innerVariable: " + innerVariable);
        }

        // innerVariable은 if문 블록 안에서만 유효하므로 사용할 수 없다.
        // System.out.println("innerVariable: " + innerVariable);

        // 메서드 실행 종료 후 지역 변수는 소멸된다.
    }

    // 메서드 외부에서는 전역 변수만 사용 가능하다.
    public static void someMethod() {
        // System.out.println("localVariable: " + localVariable);
    }
}
```

위 코드에서 `globalVariable`은 전역 변수로 메서드 내부에서도 사용할 수 있다. `localVariable`은 `main()` 메서드 내에서 선언된 지역 변수이므로 해당 메서드 내에서만 사용할 수 있다. `innerVariable`은 `if`문 블록 안에서 선언된 지역 변수이므로 해당 블록 안에서만 사용할 수 있다.

또한, `main()` 메서드가 종료되면 지역 변수 `localVariable`은 소멸다. `someMethod()` 메서드에서는 `localVariable`을 사용할 수 없다. 전역 변수 `globalVariable`은 프로그램 시작 시 생성되어 프로그램 종료 시 소멸된다.

## 타입 변환, 캐스팅 그리고 타입 프로모션

자바에서는 다른 데이터 타입 간에 변환할 수 있다. 타입 변환이란 하나의 데이터 타입을 다른 데이터 타입으로 변환하는 것을 의미한다. 이는 변수의 값을 다른 변수에 할당하거나, 메소드 인자를 전달하거나, 메소드 리턴 값을 받을 때 발생할 수 있다.

타입 변환에는 크게 두 가지 종류가 있다. 하나는 자동 타입 변환(타입 프로모션)이고, 다른 하나는 강제 타입 변환(캐스팅)이다.

### 자동 타입 변환 (타입 프로모션)

자동 타입 변환은 작은 크기의 데이터 타입이 더 큰 크기의 데이터 타입으로 변환되는 것이다. 이 경우 자동으로 변환되기 때문에 명시적인 캐스팅 연산자가 필요하지 않다.

```java
byte b = 10;
int i = b; // byte가 int로 자동 타입 변환
```

위의 예제에서는 `byte` 타입의 `b` 변수를 `int` 타입의 `i` 변수에 할당하고 있다. `byte` 타입은 1바이트의 크기를 가지고 있지만, `int` 타입은 4바이트의 크기를 가지고 있다. 따라서 `b` 변수의 값을 `i` 변수에 할당할 때 `b` 변수의 값이 자동으로 `int` 타입으로 변환되어 할당된다.

### 강제 타입 변환 (캐스팅)

강제 타입 변환은 더 큰 크기의 데이터 타입이 작은 크기의 데이터 타입으로 변환되는 것이다. 이 경우 명시적인 캐스팅 연산자가 필요하다.

```java
int i = 1000;
byte b = (byte)i; // int가 byte로 강제 타입 변환
```

위의 예제에서는 `int` 타입의 `i` 변수를 `byte` 타입의 `b` 변수에 할당하고 있다. `int` 타입은 4바이트의 크기를 가지고 있지만, `byte` 타입은 1바이트의 크기를 가지고 있다. 따라서 `i` 변수의 값을 `b` 변수에 할당할 때 명시적으로 `int` 타입에서 `byte` 타입으로 캐스팅 연산자를 사용하여 변환하고 있다.

강제 타입 변환은 데이터의 손실이 발생할 수 있으므로 주의해야 한다. 위의 예제에서 `i` 변수의 값이 `-128`보다 작거나 `127`보다 큰 경우 `byte` 타입으로 변환될 때 데이터의 손실이 발생한다.

## 1차 및 2차 배열 선언하기

배열(Array)란 순차적이고 인덱스 값을 가지고 직접 접근이 가능한 Random Access 특징을 가진다. 배열이 선언되면 데이터는 Heap 메모리에 저장된다.

1차원 배열을 선언하고 어떻게 Heap 메모리에 저장되는지 확인해보자.

```java
class Main {
    public static void main(String[] args) {
        //1차원 배열의 선언
        int[] arr = {1, 2, 3};
        int[] arr2 = new int[3];
    }
}
```

arr 배열은 int타입으로 1,2,3을 값으로 가지는 3 크기의 배열을 생성한다.

arr2의 경우 배열의 크기로 선언해준다. (이러한 경우 초기화는 0으로 통일된다.)

arr배열과 arr2 배열은 Heap에 아래와 같은 형식으로 저장된다.

<p align="center">
    <img width="701" alt="image" src="https://user-images.githubusercontent.com/105579811/235336474-89190c81-330e-4fc9-ae51-d6e7f51afbf7.png"/>
</p>

이번엔 2차원 배열을 선언하고 어떻게 저장되는지 확인해보자.

```java
class Main {
    public static void main(String[] args) {
        //2차원 배열의 선언
        int[][] arr = {{1, 2}, {3, 4}};
        int[][] arr2 = new int[2][2];
    }
}
```

2차원 배열은 먼저 인덱스로 해당 인덱스 배열의 주소에 접근한 후 해당 주소를 가지고 데이터에 다시 접근한다. 그림으로 나타내면 이렇게 그려진다.

<p align="center">
    <img width="704" alt="image" src="https://user-images.githubusercontent.com/105579811/235336503-c39dfa85-e8e6-465f-b61e-ed1ad0adc912.png"/>
</p>

arr2의 경우에는 동일한 형식으로 데이터가 저장되며 똑같이 0으로 초기화된다.

지금까지 보여준 배열은 프리미티브 타입의 배열이데 참조타입의 배열의 경우에는 어떤식으로 접근이 될까?

```java
class Main {
    public static void main(String[] args) {
        //참조타입 배열 선언
        String[] strArr = {"hello", "world"};

    }
}
```

참조타입은 new 키워드로 동적으로 할당되기 때문에 해당 데이터의 주소값을 생성시에 가지고 있다. 따라서, 참조타입의 배열은 2차원 배열과 비슷한 느낌으로 참조 타입 생성 객체 주소에 접근할 것이고 생성된 객체가 가지고 있는 주소에 해당 데이터가 존재할 것이다.

<p align="center">
    <img width="712" alt="image" src="https://user-images.githubusercontent.com/105579811/235336547-2ed191e3-1798-4d00-b7c8-0d77d1670347.png"/>
</p>

## 타입 추론, var

Java의 타입 추론이란 코드 작성 당시 타입이 정해지지 않았지만, 컴파일러가 그 타입을 유추하는 것을 말한다.

Java 10이하 버전에서 타입추론은 제네릭과 람다식에서 타입추론 개념이 존재했다.

Java 10 버전 부터는 var 키워드가 추가되었다. var 키워드는 지역 변수이면서 동시에 초기화가 필수적으로 요구된다. 따라서, 멤버 변수 필드 선언, 생성자 형식 변수 또는 다른 종류 변수 선언에는 사용할 수 없다.

```java
var str = "hello";                      //String임을 추론 가능
var list = new ArrayList<Integer>();    //ArrayList타입임을 추론 가능
```

<br/>
<br/>

참조

[백기선님과 함께하는 Live Study 2주차 - 자바 데이터 타입, 변수 그리고 배열](https://zayson.tistory.com/entry/%EB%B0%B1%EA%B8%B0%EC%84%A0%EB%8B%98%EA%B3%BC-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-Live-Study-2%EC%A3%BC%EC%B0%A8-%EC%9E%90%EB%B0%94-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85-%EB%B3%80%EC%88%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%B0%B0%EC%97%B4#%ED%--%--%EB%A-%AC%EB%AF%B-%ED%-B%B-%EB%B-%-C%--%ED%--%--%EC%-E%--%--%EC%A-%--%EB%A-%--%EC%--%--%--%EA%B-%--%EC%-D%--%--%EB%B-%--%EC%-C%--%--%EA%B-%B-%EB%A-%AC%EA%B-%A-%--%EA%B-%B-%EB%B-%B-%--%EA%B-%--)
