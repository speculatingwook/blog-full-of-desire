---
title: '스프링 시큐리티(Spring security)의 개념'
date: '2023-05-08'
tags: ['spring', 'spring_security']
draft: false
summary: 로그인 기능에 꼭 필요한 스프링 시큐리티
---

## 스프링 시큐리티의 특징

1. 서블릿 API 통합
2. Spring Web MVC와의 선택적 통합
3. 인증과 권한 부여를 모두 포괄적이고 확장 가능한 지원
4. 세션 고정, clickjacking, 사이트 간 요청 위조 등과 같은 공격으로부터 보호

## 스프링 시큐리티가 요청을 처리하는 방식

<p align="center">
    <img alt="image" width="600" src="https://github.com/speculatingwook/blog-full-of-desire/assets/105579811/a8a0c6aa-700d-48f8-b617-e97167219e45"/>
</p>

스프링 시큐리티는 서블릿 필터체인을 자동으로 구성하고 요청을 거치게 한다.

<p align="center">
    <img width="882" alt="image" src="https://user-images.githubusercontent.com/105579811/236806863-291c52fc-7810-4b4d-9573-6371cb1b8dc3.png"/>
</p>

1. 유저 로그인 시도 -->`AuthenticationFilter`가 `Http servlet Request`에서 사용자가 보낸 정보를 intercept한다.
2. 인증용 객체인 `UsernamePasswordAuthenticationToken`을 생성한다.
3. `UsernamePasswordAuthenticationToken`을 `AuthenticationManager interface`에 위임을 하게 된다. 만약 성공한다면 `Authentication` 객체를 반환한다.
4. 반환한 `Authentication` 객체를 `AuthenticationProvider`에게 전달한다.
5. `Authentication` 객체를 `UserDetailsService`에 전달한다.
6. `UserDetailsService`는 만약 `Authentication`을 가지로 DB에 있는 User임을 하게 된다면, `UserDetails`에서 `User`를 꺼내서 유저 세션을 생성하게 된다.
7. 가져온 `UserDetails`를 Spring Sequrity의 인메모리 세션 저장소인 `SecurityContextHolder`에 저장을 한다.
8. 이후, 유저 세션ID와 함께 응답을 보내게 된다.

### `AutenticationManager`의 구조

<p align="center">
    <img alt="image" width="600" src="https://github.com/speculatingwook/blog-full-of-desire/assets/105579811/6581065e-c03d-45c3-af42-f527f4ed9c87"/>
</p>

## 시큐리티의 주요 필터

### `SecurityContextPersistenseFilter`

- SecurityContextRepository를 통해 SecurityContext를 Load/Save 처리

### `LogoutFilter`

- 로그아웃 URL(기본값: /logout)로의 요청을 감시하여 해당 사용자를 로그아웃 시킴

### `UsernamePasswordAuthenticationFilter`

- ID/PW 기반 Form 인증 요청 URL(기본값: /login)을 감시하여 사용자를 인증함

### `ExceptionTransiationFilter`

- 요청을 처리하는 중에 발생할 수 있는 예외를 위임하거나 전달

### `FilterSecurityInterceptor`

- 접근 권한 확인을 위해 요청을 AccessDecisionManager로 위임. 이 필터가 실행되는 시점에는 사용자가 인증됐다고 판단

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .cors() // CORS 설정 활성화
    .and()
        .sessionManagement() // 세션 관리 설정
        .sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 세션 생성 정책을 Stateless로 설정
    .and()
        .csrf().disable() // CSRF 방지 기능 비활성화
        .formLogin().disable() // 폼 로그인 기능 비활성화
        .httpBasic().disable() // 기본 HTTP 인증 기능 비활성화
        .exceptionHandling() // 예외 처리 설정
        .authenticationEntryPoint(new RestAuthenticationEntryPoint()) // 사용자 정의 인증 진입점 설정
        .accessDeniedHandler(tokenAccessDeniedHandler) // 사용자 정의 접근 거부 핸들러 설정
    .and()
        .authorizeRequests() // 요청 인증 설정
        .requestMatchers(CorsUtils::isPreFlightRequest).permitAll() // CORS 전처리 요청에 대해 인증을 허용
        .antMatchers("/api/**").hasAnyAuthority(RoleType.USER.getCode()) // "/api/**" 패턴의 URL에 USER 권한이 있는 경우 접근 허용
        .antMatchers("/api/**/admin/**").hasAnyAuthority(RoleType.ADMIN.getCode()) // "/api/**/admin/**" 패턴의 URL에 ADMIN 권한이 있는 경우 접근 허용
        .anyRequest().authenticated() // 나머지 요청은 모두 인증 받은 사용자만 접근 가능
    .and()
        .oauth2Login() // OAuth2 로그인 설정
        .authorizationEndpoint()
        .baseUri("/oauth2/authorization") // 인증 엔드포인트 기본 URI 설정
        .authorizationRequestRepository(oAuth2AuthorizationRequestBasedOnCookieRepository()) // 사용자 정의 인증 요청 저장소 설정
    .and()
        .redirectionEndpoint() // 리다이렉션 엔드포인트 설정
        .baseUri("/*/oauth2/code/*") // 리다이렉션이 발생하는 기본 URI 설정
    .and()
        .userInfoEndpoint() // 사용자 정보 엔드포인트 설정
        .userService(oAuth2UserService) // 사용자 정보 서비스 설정
    .and()
        .successHandler(oAuth2AuthenticationSuccessHandler()) // OAuth2 인증 성공 핸들러 설정
        .failureHandler(oAuth2AuthenticationFailureHandler()); // OAuth2 인증 실패 핸들러 설정

    http.addFilterBefore(tokenAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); // 사용자 정의 필터를 필터 체인에 추가
}
```
