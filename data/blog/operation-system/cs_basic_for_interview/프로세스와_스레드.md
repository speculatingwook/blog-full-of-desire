---
title: '3. 프로세스와 스레드'
date: '2023-04-12'
tags: ['OPERATION_SYSTEM', 'COMPUTER_SCIENCE']
draft: false
summary: '친한 형이 준 운영체재 자료 요점정리'
---

프로세스(process)는 컴퓨터에서 실행되고 있는 프로그램을 말하며 CPU 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰인다. 스레드는 프로세스 내 작업의 흐름을 지칭한다.

<p align="center">
    <img width="244" alt="image" src="https://user-images.githubusercontent.com/105579811/231328162-3c25704d-6b3c-4f82-9554-38da8c0647b6.png"/>
</p>

위의 그림처럼 프로그램이 메모리에 올라가면 프로세스가 되는 인스턴스화가 일어나고, 이후 운영체제의 CPU 스케줄러에 따라 CPU가 프로세스를 실행한다.

## 3.1 프로세스와 컴파일 과정

프로세스는 프로그램으로부터 인스턴스화괸 것을 말한다. 예를 들어 프로그램은 구글 크롬 프로그램(chrome.exe)와 같은 실행파일이며, 이를 두 번 클릭하면 구글 크롬 '프로세스'가 시작이 된다.

프로그램은 컴파일러가 컴파일 과정을 거쳐 컴퓨터가 이해할 수 있는 기계어로 번역되어 실행될 수 있는 파일이 되는 것을 의미하며 '컴파일 과정'이란 다음과 같다. 참고로 여기서 말하는 프로그램이란 C언어 기반의 프로그램을 의미하며, 이는 별도의 컴파일 과정 없이 한번에 한 줄씩 읽어들여서 길행하는 프로그램인 인터프리터 언어(파이썬 등)로 된 프로그램과는 다르다.

- 프로그램의 컴파일 과정

<p align="center">
    <img width="441" alt="image" src="https://user-images.githubusercontent.com/105579811/231328859-0de54131-aa41-452d-8292-9a3993a51853.png"/>
</p>

### 전처리

소스코드의 주석을 제거하고 #include 등 헤더 파일을 병합하여 매크로를 치홚나다.

### 컴파일러

오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환한다.

### 어셈블러

어셈블리어는 목적 코드(object code)로 변환된다. 이때 확장자는 운영체제마다 다른데 리눅스에서는 .o이다. 예를 들어 가영.c라는 파일을 만들었을 때 가영.o라는 파일이 만들어지게 된다.

### 링커

프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만든다. 실행 파일의 확장자는 .exe 또는 .out 이라는 확장자를 갖는다.

#### 정적 라이브러리와 동적 라이브러리

라이브러리는 정적 라이브러리와 동적 라이브러리로 나뉜다.

정적 라이브러리는 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식이며, 시스템 환경 등 외부 의존도가 낮고 코드 중복 등 메모리 효율성이 떨어지는 단점이 있다.

동적 라이브러리는 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하는 방식이고, 메모리 효율성에서의 장점과 외부 의존도가 높아진다는 단점이 있다.

<br/>

## 3.2 프로세스의 상태

프로세스의 상태는 여러가지 상태 값을 갖는다.

<p align="center">
    <img width="349" alt="image" src="https://user-images.githubusercontent.com/105579811/231334015-fc072107-a4d3-4f98-94ea-1669b5eba14d.png"/>
</p>

### 생성 상태

생성상태(create)는 프로세스가 생성된 상태를 의미하며 fork() 또는 exec() 함수를 통해 생성한다. 이때 PCB가 할당된다.

#### fork()

fork()는 부모 프로세스의 주소공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수이다. 주소 공간만 복사할 뿐이지 부모 프로세스의 비동기 작업 등을 상속하지는 않는다.

#### exec()

exec()은 새롭게 프로세스를 생성하는 함수이다.

<br/>

### 대기 상태

대기 상태(ready)는 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기하고 있으며 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태이다.

### 대기 중단 상태

대기 중단 상태(ready suspended)는 메모리 부족으로 일시 중단된 상태이다.

### 실행 상태

실행 상태(running)는 CPU 소유권과 메모리를 할당받고 인스트럭션을 수행중인 상태를 의미한다. 이를 CPU burst가 일어났다고도 표현한다.

### 중단 상태

중단 상태(blocked)는 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태이다. I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생하기도 한다. 예를 들어 프린트 인쇄 버튼을 눌렀을 때 프로세스가 잠깐 멈춘 듯할 때가 있다. 그 상태가 중단상태이다.

### 일시 중단 상태

일시 중단 상태(blocked suspended)는 대기 중단과 유사하다. 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태이다.

### 종료 상태

종료 상태(terminated)는 메모리와 CPU 소유권을 모두 놓고 가는 상태를 말한다. 종료는 자연스럽게 종료되는 것도 있지만 부모 프로세스가 자식 프로세스를 강제시키는 비자발적 종료(abort)로 종료되는 것도 있다. 자식 프로세스에 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process.kill 등 여러 명령어로 프로세스를 종료할 때 발생한다.

<br/>

## 3.3 프로세스의 메모리 구조

운영체제는 프로세스에 적절한 메모리를 할당하는데 다음 구조를 기반으로 할당한다.

<p align="center">
    <img width="271" alt="image" src="https://user-images.githubusercontent.com/105579811/231335641-3e0fa95e-115c-497e-bcac-62e3d9883f7e.png"/>
</p>

위에서부터 스택(stack), 힙(heap), 데이터 영역(BSS segment, Data segment), 코드 영역(code segment)으로 나눠진다. 스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당된다.

### 스택

스택에는 지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정되며 '동적'인 특징을 갖는다.

스택 영역은 함수가 함수를 재귀적으로 호출하면서 동적으로 크기가 늘어날 수 있는데, 이때 힙과 스택의 메모리 영역이 겹치면 안되기 때문에 힙과 스택 사이의 공간을 비워놓는다.

### 힙

힙은 동적 할당할 때 사용되며 런타임 시 크기가 결정된다. 예를 들어 벡터 같은 동적 배열은 당연히 힙에 동적 할당된다. 힙은 '동적'인 특징을 가진다.

### 데이터 영역

데이터 영역은 전역변수, 정적변수가 저장되고, 정적인 특징을 갖는 프로그램이 종료되면 사라지는 변수가 들어 있는 영역이다.
데이터 영역은 BSS 영역과 Data 영역으로 나뉘고, BSS 영역은 초기화가 되지 않는 변수가 0으로 초기화되어 저장되며 Data 영역(Data segment)은 0이 아닌 다른 값으로 할당된 변수들이 저장된다.

### 코드 영역

코드 영역은 프로그램에 내장되어 있는 소스 코드가 들어가는 영역이다. 이 영역은 수정 불가능한 기계어로 저장되어 있으며 정적인 특징을 가진다.

## 3.4 PCB
