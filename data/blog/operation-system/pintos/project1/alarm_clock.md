---
title: '[ Pintos ] alarm-clock'
date: '2023-07-06'
tags: ['operating-system', 'side-project', 'pintos']
draft: false
summary: pintos project 1, threads-alarm-clock
---

## Alarm Clock

알람 시계(Alarm Clock)는 멀티스레드 프로그래밍에서 사용되는 개념입니다. 알람 시계는 특정 시간에 스레드를 깨우거나 일시 정지 상태에서 깨워주는 역할을 합니다.

일반적으로 알람 시계는 스레드의 슬립(sleep)이나 대기(wait) 상태에서 동작합니다. 스레드는 특정 작업을 수행하다가 일시적으로 대기 상태로 들어갈 수 있는데, 이때 알람 시계를 사용하여 특정 시간에 스레드를 깨울 수 있습니다.

알람 시계를 사용하기 위해서는 일정한 시간 간격으로 스레드를 깨우기 위한 시간 제한을 설정해야 합니다. 일반적으로 운영체제나 프로그래밍 언어에서 제공하는 시간 함수를 사용하여 시간을 측정하고, 이를 기반으로 알람 시계를 설정합니다.

스레드 간의 동기화를 위해 한 스레드가 특정 작업을 마치고 다른 스레드를 깨워야 할 때 알람 시계를 활용할 수 있습니다. 또한 정기적으로 반복되는 작업을 수행해야 할 때도 알람 시계를 사용하여 스레드를 깨울 수 있습니다.

### Reimplementing `timer_sleep()`, defined in `devices/timer.c`.

주어진 구현은 바쁜 대기(**busy waiting**)를 수행합니다. 즉, 현재 시간을 확인하고 `thread_yield()`를 호출하여 충분한 시간이 경과할 때까지 반복하는 방식입니다. 바쁜 대기를 피하기 위해 재구현해야 합니다.

```c
void timer_sleep (int64_t ticks);
```

호출한 스레드의 실행을 중단하고 시간이 최소한 x 타이머 틱만큼 진행될 때까지 대기합니다. 시스템이 다른 작업을 수행하지 않는 한, 스레드는 정확히 x 틱 후에 깨어나지 않아도 됩니다. 그저 올바른 시간만큼 대기한 후 준비 큐(ready queue)에 스레드를 넣어두세요.

`timer_sleep()` 함수는 실시간으로 작동하는 스레드에 유용합니다. 예를 들어, 1초마다 커서를 깜빡이는 작업에 사용될 수 있습니다. `timer_sleep()` 함수의 인수는 타이머 틱 단위로 표현되며, 밀리초나 다른 단위가 아닙니다. 1초에는 TIMER_FREQ 타이머 틱이 있으며, TIMER_FREQ는 `devices/timer.h`에 정의된 매크로입니다. 기본값은 100입니다. 많은 테스트가 실패할 수 있으므로 이 값을 변경하는 것을 권장하지 않습니다.

특정 시간(밀리초, 마이크로초, 나노초) 동안 대기하기 위한 별도의 함수인 `timer_msleep()`, `timer_usleep()`, `timer_nsleep()`도 있습니다. 이들은 필요할 때 자동으로 `timer_sleep()`를 호출합니다. 따라서 이들 함수를 수정할 필요는 없습니다. 알람 시계 구현은 이후 프로젝트에 필요하지 않지만, 프로젝트 4에서 유용할 수 있습니다.

## 음, 이해는 했는데, 이제 뭘 해야 하지?

일단, 구글링을 조금 해봤습니다. [좋은 블로그](https://poalim.tistory.com/28)가 있길래 조금씩 참고하면서 진행하려고 합니다.

## Busy Waiting

Busy waiting은 프로그램이나 스레드가 작업을 기다리는 동안 반복문을 실행하며 지속적으로 CPU를 사용하는 방식입니다. Busy waiting은 일반적으로 특정 조건이 충족될 때까지 계속해서 반복하여 확인하며, 조건이 충족되면 작업을 계속합니다.

Busy waiting은 기다리는 동안 CPU 시간을 지속적으로 소비하므로, 자원의 낭비와 성능 저하를 초래할 수 있습니다. 이는 다른 작업이 실행될 수 있는 기회를 제한하고, 전체 시스템의 처리량을 감소시킬 수 있습니다. 또한, Busy waiting은 무한 루프에 빠질 수 있으며, 이 경우 CPU 리소스를 지속적으로 소비하게 됩니다.

Busy waiting은 특정 작업이 완료되기를 기다리거나, 공유 자원에 대한 접근 가능 여부를 확인하는 등의 상황에서 사용될 수 있습니다. 예를 들어, 동기화 기법 중 하나인 스핀락(Spinlock)은 Busy waiting을 사용하여 공유 자원의 잠금 상태를 확인하고 대기하는 방식으로 동작합니다. 스핀락은 일시적인 대기 시간이 짧은 경우에 유용하며, 잠금이 해제될 때까지 지속적으로 반복하여 확인합니다.

하지만 Busy waiting은 대기 시간 동안 CPU를 계속해서 사용하므로, 대기 시간이 길거나 다른 작업에 우선순위를 주어야 하는 경우에는 비효율적일 수 있습니다. 이러한 경우에는 대기열(Queue)이나 블로킹 기법(Block) 등의 다른 동기화 기법을 사용하는 것이 더 적합할 수 있습니다. 대기열이나 블로킹 기법은 스레드를 일시 정지 상태로 만들고, 작업이 완료되거나 자원이 사용 가능해질 때까지 대기할 수 있도록 합니다.

따라서 Busy waiting은 상황에 따라 적절하게 사용되어야 합니다. 작업의 특성과 대기 시간의 길이, 시스템의 요구사항 등을 고려하여 적절한 동기화 기법을 선택하는 것이 중요합니다.
