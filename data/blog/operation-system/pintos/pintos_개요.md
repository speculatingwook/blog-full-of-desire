---
title: 카이스트 전산과의 학부 프로젝트, pintos
date: '2023-06-30'
tags: ['operating-system', 'side-project']
draft: false
summary: 카이스트 출신 개발자 사수분이 알려주신 PINT-OS, 작은 OS 구현 프로젝트
---

## 들어가며

지금 나는 학교 현장실습으로 한 회사에서 인턴으로 근무를 하고 있다. 회사 분위기가 생각보다 자유로워서 사수분과 이런저런 이야기를 나눌 기회가 많았다.

전 프로젝트를 할 때의 사수형은 객체지향 프로그래밍으로 중점적으로 개발을 하시는 분이었다면, 이번 사수분은 함수형 프로그래밍에 대한 이해도가 높은 것 같았다. 그래서 커피챗을 하면서 이런 저런 이야기를 나누었고, 좋은 정보들을 주고받을 수 있었다.

그러다가 사수개발자분께서 학부 시절때 했던 프로젝트 링크를 보내주셨다. 이 프로젝트는 카이스트 학부 수업때 하는 프로젝트였고, 작은 OS를 직접 구현해보는 프로젝트였다. 나는 이 프로젝트를 보자마자 너무 끌렸고, 시간이 날 때마다 해야겠다고 생각했다. 아래는 해당 링크이다.

[casys-kaist.github.io/pintos](https://casys-kaist.github.io/pintos-kaist/)

## 소개

환영합니다! KAIST CS330의 Pintos 프로젝트에 참여하신 것을 환영합니다. 이 학기에는 KAIST의 CS330 수업을 위해 특별히 맞춤 수정된 Pintos 버전을 사용할 예정입니다.

수정된 Pintos 버전은 기본 버전과 요구 사항이 약간 다를 수 있으므로, 이 매뉴얼의 지침을 우선적으로 따르셔야 합니다. 이전 개인 Pintos 프로젝트를 참조할 수는 있지만, 업데이트된 내용에 따라 일부를 다시 구현해야 할 수도 있습니다.

변경 사항으로 인해 멘토분들이 매뉴얼을 수정했습니다. 그러나 멘토분들이 수정된 버전과 매뉴얼을 완전히 동기화하지 못한 경우도 있을 수 있습니다. 그런 부분을 발견하시면 멘토분들에게 알려주시면 감사하겠습니다.

Pintos의 원본 버전은 자유로운 라이선스 하에 무료로 사용, 수정 및 배포가 가능합니다. Pintos에서 작업하는 학생과 다른 사람들은 자신이 작성한 코드에 대한 권리를 가지고 있으며, 이를 어떤 목적으로든 사용할 수 있습니다. Pintos는 어떤 형태로든 보증되지 않으며, 상업성이나 특정 목적에의 적합성조차 보장하지 않습니다. 라이선스 세부 사항과 보증 부재에 관해서는 License 파일을 참조하시기 바랍니다. 그러나 pintos-kaist의 수정된 코드는 동일한 라이선스에 포함되지 않습니다. 대신 RECEX SHARED SOURCE LICENSE를 사용하며, 이는 이 코드를 기반으로한 작업을 재배포해서는 안된다는 것을 의미합니다. 자세한 내용은 LICENSE 파일을 참조해 주세요.

KAIST의 CS330 과정에서는 온라인이나 다른 곳에서 사용 가능한 숙제 해결책을 읽지 않는 것이 요구됩니다. Pintos 작업 시에는 명예 코드의 정신과 원칙을 존중해 주시기 바랍니다. 다른 운영 체제 커널의 소스 코드(예: Linux 또는 FreeBSD)를 읽는 것은 허용되지만, 그 코드를 그대로 복사하여 사용하는 것은 피해야 합니다.

Pintos-kaist는 x86-64 아키텍처를 위한 간단한 운영 체제 프레임워크입니다. 이 프로젝트는 스탠포드 대학에서 시작된 Pintos 프로젝트를 기반으로 하였으며, Pintos는 커널 스레드, 사용자 프로그램 로드 및 실행, 파일 시스템을 지원하지만, 모두를 매우 간단한 방식으로 구현합니다. Pintos 프로젝트에서는 여러분과 팀이 이러한 기능들을 강화하고, 가상 메모리 구현을 추가하는 작업을 수행할 것입니다.

이론적으로, Pintos는 일반적인 x86-64 PC에서 실행할 수 있지만, 모든 CS330 학생들에게 전용 PC를 제공하는 것은 현실적으로 어렵습니다. 따라서 Pintos 프로젝트는 시스템 시뮬레이터에서 실행됩니다. 시뮬레이터는 수정되지 않은 운영 체제와 소프트웨어가 정확하게 x86-64 CPU와 주변 장치를 시뮬레이트하는 프로그램입니다. 수업에서는 QEMU 시뮬레이터를 사용합니다.

Pintos 프로젝트는 어려운 작업들을 포함하고 있습니다. CS330은 많은 시간과 노력이 필요한 어려운 과목으로 악명이 높습니다. 우리는 최대한 작업 부담을 줄이고 많은 지원 자료를 제공하기 위해 노력할 것입니다. 그러나 여전히 도전적인 작업들이 많이 있습니다. 여러분의 피드백을 환영하며, 과제의 불필요한 부담을 줄이고 중요한 근본적인 문제에 집중할 수 있는 방법을 찾는다면 알려주세요.

이 장은 Pintos를 시작하는 방법에 대해 설명하고 있습니다. 이 장을 전체적으로 읽은 후에 프로젝트 작업을 시작하시면 됩니다. 추가적인 도움이 필요하시면 언제든지 문의해 주세요.

## Getting Started

Pintos를 빌드할 수 있는 기계에 로그인해야 시작할 수 있습니다. 멘토가 제공한 Linux 기계를 사용하거나, 직접 소유한 Solaris 또는 Linux 기계를 사용할 수 있습니다. 하지만, 우리는 주어진 기계에서 코드를 테스트할 것이며, 여기서 제공된 안내사항은 이러한 환경을 가정하고 있습니다. 개인 기계에서 Pintos 설치 및 작업 지원은 제공하지 않습니다. 아래에 제공된 서버 환경은 각 학생에게 제공됩니다.

참고로, 우리는 Ubuntu 16.04.6 LTS에서 gcc (gcc (Ubuntu 7.4.0-1ubuntu116.04ppa1) 7.4.0) 및 qemu-system-x86_64 (QEMU emulator version 2.5.0 (Debian 1:2.5+dfsg-5ubuntu10.43))와 같은 버전의 Linux 머신에서 pintos 코드와 솔루션을 테스트했습니다.

소스 코드를 가져왔으면, pintos 루트 디렉토리에서 다음 명령어로 환경을 설정할 수 있습니다.

```shell
source ./activate
```

매번 로그인할 때마다 이를 입력해야 하는 번거로움을 피하기 위해 홈 디렉토리의 .bashrc에 이 줄을 추가하는 것이 좋습니다.

## Source Tree Overview

자, 어떤 내용이 들어있는지 살펴보겠습니다. `pintos/` 디렉토리 안에 보이는 디렉토리 구조는 다음과 같습니다:

- `threads/`: 프로젝트 1부터 수정할 기본 커널의 소스 코드입니다.
- `userprog/`: 프로젝트 2부터 수정할 사용자 프로그램 로더의 소스 코드입니다.
- `vm/`: 거의 비어있는 디렉토리입니다. 프로젝트 3에서 가상 메모리를 구현할 예정입니다.
- `filesys/`: 기본 파일 시스템의 소스 코드입니다. 프로젝트 2부터 이 파일 시스템을 사용하지만, 프로젝트 4까지는 수정하지 않을 것입니다.
- `devices/`: I/O 장치 인터페이싱을 위한 소스 코드입니다: 키보드, 타이머, 디스크 등. 프로젝트 1에서 타이머 구현을 수정할 것입니다. 그 외에는 이 코드를 변경할 필요가 없을 것입니다.
- `lib/`: 표준 C 라이브러리의 일부를 구현한 코드입니다. 이 디렉토리의 코드는 Pintos 커널뿐만 아니라, 프로젝트 2부터 실행되는 사용자 프로그램에도 컴파일됩니다. 이 코드를 수정할 필요는 거의 없을 것입니다.
- `include/lib/kernel/`: Pintos 커널에서만 포함되는 C 라이브러리의 일부입니다. 여기에는 비트맵, 이중 연결 리스트, 해시 테이블과 같은 데이터 유형의 구현도 포함됩니다. 커널에서는 이 디렉토리의 헤더 파일을 `#include <...>` 형식으로 포함시킬 수 있습니다.
- `include/lib/user/`: Pintos 사용자 프로그램에서만 포함되는 C 라이브러리의 일부입니다. 사용자 프로그램에서는 이 디렉토리의 헤더 파일을 `#include <...>` 형식으로 포함시킬 수 있습니다.
- `tests/`: 각 프로젝트에 대한 테스트 코드입니다. 제출한 코드를 테스트하는 데 도움이 되는 경우 이 코드를 수정할 수 있지만, 테스트를 실행하기 전에 원본으로 복원할 것입니다.
- `examples/`: 프로젝트 2부터 사용할 수 있는 예시 사용자 프로그램입니다.
- `include/`: 헤더 파일 (`*.h`)의 소스 코드입니다.

## Building Pintos

다음 단계로, 첫 번째 프로젝트용으로 제공된 소스 코드를 빌드해야 합니다. 먼저 `threads` 디렉토리로 이동한 다음, `make` 명령어를 실행하세요. 이 명령은 `threads` 디렉토리 아래에 `build` 디렉토리를 생성하고, 그 안에 `Makefile`과 몇 개의 하위 디렉토리를 생성한 후 커널을 빌드합니다.

빌드 이후, build 디렉토리에 다음과 같은 중요한 파일들이 있습니다:

- `Makefile`: `pintos/src/Makefile.build`의 사본입니다. 커널을 빌드하는 방법을 설명합니다.
- `kernel.o`: 전체 커널의 오브젝트 파일입니다. 각 개별 커널 소스 파일에서 컴파일된 오브젝트 파일들을 링크하여 단일 오브젝트 파일로 만들어집니다. 디버그 정보를 포함하고 있으므로 GDB ([GDB]() 참조) 또는 backtrace ([Backtraces]() 참조)를 실행할 수 있습니다.
- `kernel.bin`: 커널의 메모리 이미지입니다. 즉, Pintos 커널을 실행하기 위해 메모리에 로드되는 정확한 바이트입니다. 이는 디버그 정보를 제거한 `kernel.o`입니다. 이로 인해 많은 공간이 절약되며, 커널 로더의 설계로 인해 512 KB 크기 제한에 부딪히지 않습니다.
- `loader.bin`: 커널 로더의 메모리 이미지입니다. 어셈블리 언어로 작성된 작은 코드 조각으로, 디스크에서 커널을 읽어 메모리에 로드하고 실행시킵니다. 이는 PC BIOS에서 정해진 512바이트 크기로 고정되어 있습니다. build 디렉토리의 하위 디렉토리에는 컴파일러가 생성한 오브젝트 파일(`.o`)과 의존성 파일(`.d`)이 포함되어 있습니다. 의존성 파일은 다른 소스 파일이나 헤더 파일이 변경될 때 어떤 소스 파일을 다시 컴파일해야 하는지를 make에 알려줍니다.

## Running Pintos

Pintos 시뮬레이터를 편리하게 실행하기 위해 pintos라는 프로그램을 제공합니다. 가장 간단한 경우에는 pintos argument...로 호출할 수 있습니다. 각 인자는 Pintos 커널에 전달되어 동작하도록 합니다. 이를 시도해보세요. 먼저 새로 생성된 `build` 디렉토리로 이동하세요. 그런 다음 `pintos run alarm-multiple` 명령을 실행하세요. 이 명령은 run alarm-multiple 인자를 Pintos 커널에 전달합니다. 여기서 run은 커널에게 테스트를 실행하도록 지시하고, alarm-multiple은 실행할 테스트입니다. Pintos가 부팅되고 alarm-multiple 테스트 프로그램을 실행하며, 몇 줄의 텍스트가 출력됩니다.

명령 줄에서 로그를 파일로 리다이렉트하여 시리얼 출력을 기록할 수도 있습니다. 예를 들어 `pintos -- run alarm-multiple > logfile`와 같이 사용할 수 있습니다. pintos 프로그램은 qemu 또는 가상 하드웨어를 구성하기 위한 여러 옵션을 제공합니다. 옵션을 지정하는 경우, 이들은 Pintos 커널에 전달되는 명령들 앞에 오고, `--`로 분리되어야 합니다. 이로써 전체 명령은 `pintos option... -- argument...`와 같은 형태가 됩니다. 인자 없이 pintos를 호출하면 사용 가능한 옵션 목록이 표시됩니다. 옵션에는 다음과 같은 내용이 포함됩니다: VM 출력을 어떻게 표시할지에 대한 설정 방법: `-v`를 사용하여 VGA 디스플레이를 끄거나, `-s`를 사용하여 stdin으로부터의 시리얼 입력과 stdout으로의 시리얼 출력을 차단할 수 있습니다. Pintos 커널에는 run 이외의 다른 명령과 옵션이 있습니다. 현재로서는 별로 흥미로운 내용은 아니지만, `pintos -h`를 사용하여 해당 목록을 볼 수 있습니다.

## Test

테스트 결과 점수는 우리의 테스트를 기반으로 결정됩니다. 각 프로젝트에는 여러 개의 테스트가 포함되어 있으며, 각 테스트는 `tests`로 시작하는 이름을 가지고 있습니다.

제출물을 완전히 테스트하려면 해당 프로젝트 빌드 디렉토리에서 make check를 실행해야 합니다. 이 명령은 각 테스트를 빌드한 다음 실행하고, 각각에 대해 통과 또는 실패 메시지를 출력합니다. 테스트가 실패하면 make check는 실패 원인에 대한 세부 정보를 출력합니다. 모든 테스트를 실행한 후, make check는 테스트 결과에 대한 요약을 출력합니다.

게다가 원하는 경우 개별 테스트를 실행할 수도 있습니다. 특정 테스트 `t`는 결과를 `t.output`에 기록한 다음, 스크립트는 출력을 통과 또는 실패로 평가하고 `t.result`에 판단을 기록합니다.

단일 테스트를 실행하고 평가하려면, 빌드 디렉토리에서 `.result` 파일을 명시적으로 생성하시기 바랍니다 . 예를 들어, `make tests/threads/alarm-multiple.result`와 같은 형식으로 사용합니다. make가 테스트 결과가 최신 상태라고 하더라도 다시 실행하려면 make clean을 실행하거나 `.output` 파일을 수동으로 삭제해야 합니다.

일반적으로 각 테스트는 완료 후에만 피드백을 제공합니다. 원하는 경우, make 명령 줄에서 `VERBOSE=1`을 지정하여 각 테스트의 진행 상황을 확인할 수 있습니다. 예를 들어, make check VERBOSE=1과 같이 입력하면 됩니다. 모든 테스트와 관련 파일은 `pintos/src/tests` 디렉토리에 위치해 있습니다.

당신의 제출물을 검토하기 전에 해당 디렉토리의 내용을 원본 및 수정되지 않은 사본으로 대체하여 올바른 테스트가 사용되도록 하겠습니다. 따라서 디버깅을 돕기 위해 일부 테스트를 수정할 수 있으나, 원래의 테스트를 실행하게 될 것입니다. 모든 소프트웨어에는 버그가 존재하기 때문에, 우리의 테스트 중 일부에 결함이 있을 수 있습니다. 테스트 실패가 당신의 코드의 버그가 아니라 테스트 자체의 버그라고 생각하는 경우 알려주십시오. 우리는 문제를 검토하고 필요한 경우 수정할 것입니다.

test suite을 악용하려는 시도는 인정되지 않습니다. 테스트 케이스만 통과하기 위해 커널 동작을 명시적으로 변경하는 것은 허용되지 않습니다. 코드는 일반적인 경우에도 올바르게 작동해야 합니다. 테스트 케이스의 이름을 기반으로 커널 동작을 결정하는 것은 불허됩니다. 이런 종류의 테스트 케이스 우회 시도는 점수를 받지 못하게 됩니다. 만약 이와 같은 상황이 불분명하다고 생각되면, 문의해 주세요.
