---
title: '[ OS ] 동시성 문제(Concurrency Issue)'
date: '2023-11-30'
tags: ['COMPUTER_SCIENCE', 'Operation_System']
draft: false
summary: '톰캣을 구현해보며 공부하는 동시성 문제'
---

## 동시성 이슈란?

> 동시성 문제란, 두 개의 상태의 세션이 공통된 자원에 대해 모두 읽고 쓰는 작업 (Read → Write)를 할 때 발생하는 문제를 뜻한다.

## Critical Section

임계구역이라고 하는 Critical Section은 한 번에 하나의 프로세스만 엑세스 할 수 있는 코드 영역을 의미한다.

프로세스는 일반적으로 4가지의 코드 영역으로 나뉜다.

<p align="center">
  <img
    width="389"
    alt="image"
    src="https://github.com/speculatingwook/blog-full-of-desire/assets/105579811/415386bf-c200-4a97-b66c-9c21e3b16589"
  />
</p>

### Entry Section

> Critical Section에 진입하기 위해 진입허가 요청을 하는 영역이다.
> Critical Section에 진입하는 것을 제어한다 하는데 이를 Lock한다고 한다.

### Critical Section

> 하나의 프로세스 만 접근할 수 있는 영역이다.

### Exit Section

> Lock을 해체하는 등, 더 이상 Critical Section에 존재하지 않을 때 알리는 역할을 한다.

### Reminder Section

> 입력 섹션, 중요 섹션 및 종료 섹션을 제외한 코드의 다른 부분을 나머지 섹션이라고 한다.

Critical Section(임계 구역)에는 둘 이상의 프로세스가 동시에 접근을 할 수 없다. 각 프로세스별로 자신의 임계구역에 들어가기 위해서는 Entry Section에서 진입 허가를 받고 접근을 해야 한다.

만약, 여러 프로세스가 동시에 임계구역에 접근을 하려고 한다면 Race Condition이 발생을 한다.

## RaceCondition

> 여러 프로세스가 동시에 공유 데이터에 접근을 할 때 실행 순서에 따라서 결과값이 달라지는 것을 의미한다.

<p align="center">
  <img
    width="611"
    alt="image"
    src="https://github.com/speculatingwook/blog-full-of-desire/assets/105579811/cc5e22de-8497-4844-a17b-44b597cae472"
  />
</p>
예를 들어, 사람 A와 사람 B가 있다고 하자. 사람 A가 은행이라는 자원에서 돈을 입금하고, 사람 B가 입금을
하면 문제가 없을 것이다. 하지만 위 그림처럼 한번에 은행 금액을 조회, 수정, 저장을 하면 큰 문제가 발생한다.
이런 에러의 발생이 바로 RaceCondition이다.

## RaceCondition의 해결방법

이런 RaceCondition을 해결하는 방법에는 크게 두가지가 있다. 세마포어(Semaphore)와 뮤텍스(Mutual Exclusion)이다. 이 두 해결방법의 차이는 메커니즘과 동기화 대상의 차이이다.

### 세마포어(Semaphore)

> 락을 걸지 않은 프로세스, 혹은 스레드도 Signal을 보내 Lock을 해제할 수 있다.
> 시그널을 통해서 프로세스 혹은 스레드의 Lock을 잠그고 풀 수 있다.

### 뮤텍스(Mutex)

> 하나의 프로세스 혹은 스레드만이 Lock을 걸고 풀 수 있다.

## DeadLock

앞선 RaceCondition을 해결하게 되더라도 또 다른 문제가 있다. 특정 조건에서 둘 이상의 작업이나 프로세스가 서로 상대방의 작업이 끝나기를 기대리며 무한히 멈춰 있을 수 있다. 각 작업은 다른 작업이 가진 자원을 기다리는데, 동시에 자신이 자원을 놓지 않아 상호간에 대기 상태에 머무르게 된다. 이걸 DeadLock이라고 부른다.

특정조건은 총 4가지이다.

> 1. 상호 배제(Mutual Exclusion)
> 2. 점유 대기(Hold and Wait)
> 3. 비선점(No Preemption)
> 4. 순환 대기(Circular Wait)

이 조건들을 보니 어디서 본 조건이 있다. 바로 Mutual Exclusion(Mutex), 상호배제이다. 그래서 RaceCondition에서 문제를 해결 할 때 위 조건이 있다면 Semaphore 방법을 이용하는 것이 좋다.

## DeadLock 해결방법

DeadLock 문제를 해결하기 위해서는 4가지 방법이 있다. 교착 상태 예방, 회피, 무시, 발견 이렇게 4가지이다.

### 교착 상태 예방

> 상호 배제 조건의 제거 - 교착 상태에서는 서로 같은 공유자원을 접근할 때 발생하는 오류이다. 즉, 상호배제 조건을 제거하면 교착상태를 예바할 수 있다.
>
> 점유와 대기 조건의 제거 - 한 프로세스가 수행되기 전 모든 자원을 할당시키고, 이 후 자원이 할당되지 않을 때 다른 프로세스가 요청할 수 있게끔 하는 방법이다. - 이는 자원의 효율성 문제와 자원파악 비용, 자원 저장 및 복원 비용, 기아상태, 무한대기 등의 문제점이 있다.
>
> 비선점 조건 제거 - 비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어 준다.
>
> 환형 대기 조건의 제거 - 자원 유형에 따라 순서를 매긴다.

### 교착 상태의 회피

자원이 어떻게 요청이 될 지 추가정보를 제공하도록 요구하는 것으로, 시스템에 Circle Wait이 발생하지 않도록 자원 할당 상태를 검사하는 것이다.

방법에는 크게 두가지가 있다.

> 1. 자원 할당 그래프 알고리즘
> 2. 은행원 알고리즘

### 교착 상태의 무시

예방 혹은 회피기법을 프로그래밍해서 넣게 되면 성능에 큰 영향을 미칠 수 있다. 따라서 데드락의 발생 확률이 낮을 경우 별 다른 조치를 취하지 않는다.

### 교착 상태의 발견

감시/발견을 하는 Detection 알고리즘으로, DeadLock 발생을 체크하는 방식, 이 방식 역시 성능에는 큰 영향을 미친다.

출처

[운영체제의 동시성 문제](https://velog.io/@vpdls1511/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C)

[Programming - Atomic Operations and Critical Sections in OpenMP](https://peakd.com/hive-169321/@drifter1/programming-atomic-operations-and-critical-sections-in-openmp)
